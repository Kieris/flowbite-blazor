@using System.Text
@using Microsoft.Extensions.Primitives
@inherits Frame

<div style="@Style">
  <h2 class="group">
    <button @onclick="@HandleToggle" type="button"
            class="accordion-item @(CheckFlush() ? "accordion-btn-flush py-5" : "accordion-flush-diff p-5") @GetActive() @(First && !CheckFlush() ? "accordion-border-top" : "") @Class"
            aria-expanded="@Open.ToString()">
      @if (Header is not null)
      {
        @Header
      }

      @if (Open)
      {
        @if (ArrowUp is not null)
        {
          @ArrowUp
        }
        else
        {
          <div>
            <div name="arrowup">
              <svg class="w-3 h-3 text-gray-800 dark:text-white" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 10 6">
                <path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5 5 1 1 5"/>
              </svg>
            </div>
          </div>
        }
      }
      else
      {
        @if (ArrowDown is not null)
        {
          @ArrowDown
        }
        else
        {
          <div>
            <div name="arrowdown">
              <svg class="w-3 h-3 text-gray-800 dark:text-white" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 10 6">
                <path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="m1 1 4 4 4-4"/>
              </svg>
            </div>
          </div>
        }
      }
    </button>
  </h2>
  <div class="@(CheckFlush() ? "accordion-body-flush" : "accordion-body-default") accordion-body @(Open ? "translate-y-0" : "hidden translate-y-full")">
    @Body
  </div>
</div>

@code {
    /// <summary>
    /// The Accordion parent
    /// </summary>
    [CascadingParameter]
    private Accordion? Parent { get; set; }
  
    /// <summary>
    /// Defines the content in the header of the component
    /// </summary>
    [Parameter]
    public RenderFragment? Header { get; set; }
  
    /// <summary>
    /// optional: Arrows replacing the ArrowUp icon with another icon  
    /// </summary>
    [Parameter]
    public RenderFragment? ArrowUp { get; set; }
  
    /// <summary>
    /// optional: Arrows replacing the ArrowDown icon with another icon  
    /// </summary>
    [Parameter]
    public RenderFragment? ArrowDown { get; set; }

    /// <summary>
    /// Defines the content in the body of the component
    /// </summary>
    [Parameter]
    public RenderFragment? Body { get; set; }

    /// <summary>
    /// Flag to signal that this AccordionItem is the first in the Accordion. Not setting this to true will cause
    /// the first AccordionItem to not have a rounded top
    /// </summary>
    [Parameter]
    public bool First { get; set; }
    
    /// <summary>
    /// Defines whether the body of the component is visible
    /// </summary>
    [Parameter]
    public bool Open { get; set; }
  
    /// <summary>
    /// Defines whether the body of the component is always open
    /// </summary>
    [Parameter]
    public bool OpenAlways { get; set; }

    /// <summary>
    /// Initializes the component and adds itself to the parent for tracking
    /// </summary>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        Parent?.AddItem(this);
        if (Attributes.ContainsKey("open") || OpenAlways)
        {
            Open = true;
        }
    }

    /// <summary>
    /// Sets classes based on whether the component is "Active"
    /// </summary>
    private string GetActive()
    {
      if (Open)
      {
        if (CheckFlush())
        {
          return $"accordion-btn-active-flush {ActiveClass}";
        }
        else
        {
          return $"accordion-btn-active {ActiveClass}";
        }
      }
      return InactiveClass;
    }
  
    /// <summary>
    /// Toggles the Open property for the body of the component and closes other items in the accordion
    /// if the Multiple attribute of the Accordion is "false"
    /// </summary>
    private void HandleToggle()
    {
        if (!OpenAlways)
        {
          Open = !Open;
          if (Parent is not null && !Parent.Multiple)
          {
            if (Open)
            {
              Parent.CloseAllOthers(this);
            }
          }
          StateHasChanged();
        }
    }
  
    /// <summary>
    /// Opens the body of the component
    /// </summary>
    public void OpenMe() => Open = true;

    /// <summary>
    /// Closes the body of the component
    /// </summary>
    public void CloseMe()
    {
        if (!OpenAlways)
        {
          Open = false;
        }   
    }

    /// <summary>
    /// Returns whether component has been defined as Flush
    /// </summary>
    private bool CheckFlush() => Parent is not null && Parent.Flush;

}